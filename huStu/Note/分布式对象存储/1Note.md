# 对象存储与云存储的关系
> 对象存储是云存储的一部分.

> 云存储 = 存储服务 + 身份认证 + 监控功能 + 客户端 + ....

# 分布式存储的好处

> 可以以大量的低成本的普通pc服务器组成网络集群来提供服务.

# 对象存储和传统网络存储的区别

+ 传统的网络存储NAS,SAN
```
NAS是一个提供了存储功能和文件系统的网络服务器.客户端可以访问NAS上的文件系统,还可以上传和下载文件.

对客户端来说,NAS就是一个网络上的文件服务器.
```
```
SAN提供了块存储,把文件系统的抽象交给了客户端来管理.

对于客户端来说,SAN就是一块可以格式化并挂载的磁盘.
```

> NAS和SAN并不是完全对立的,现代网络存储通常都是两者混用的.


+ 对象存储和传统网络存储的区别

1. 数据的管理方式

```
对于网络文件系统来说,数据是以一个个文件的形式来管理的.

对于块存储来说,数据是以数据块的形式来管理的,每一个数据块都有对应的地址.

对象存储是以对象的方式来管理数据的,一个对象通常包括了3个部分:对象的数据,对象的元数据以及一个全局唯一的标识符(即对象的ID).
```

2. 访问数据的方式

```
网络文件系统的客户端通过NFS等网络协议访问某个远程服务器上存储的文件.

块存储的客户端通过数据块的地址访问SAN上的数据块.

对象存储通过REST(Representational State Transfer)网络服务访问对象.
```

3. 对象存储的优势

```
提升了存储系统的扩展性.

以更低的代价提供了数据冗余的能力.(第五章讨论优势在哪？)
传统网络存储对于数据冗余的处理方式是保留多个副本,然后用少数服从多数的方式解决争议.
```

# 服务器
## **单机版服务器(接口和数据耦合)**

![Alt](./image/截图_选择区域_20220612110314.png#pic_center)

> 接口和数据存储紧紧耦合在一起,服务器只能访问本地磁盘.当一台服务器无法满足日益增长的HTTP客户端请求数量时,无法通过加入新的服务器来扩展集群.

+ **改进**

> 把接口和数据存储解耦合,分离成专门的接口服务和数据服务,接口服务器可以任意访问一台数据服务器.

> 当http请求增长时,我们可以加入新的接口服务器,保持数据服务器不变,而当数据存储满或磁盘io负载过高时,可以加入新的数据服务器,保持接口服务器不变.

##  **分布式系统(接口和数据解耦合)** 

![Alt](./image/截图_选择区域_20220612113138.png#pic_center)

> 接口服务层提供了对外的REST接口,数据服务层提供了数据的存储功能.

> 接口服务处理客户端的请求,然后向数据服务存取对象,数据服务处理来自接口服务的请求并在本地磁盘上存取对象.

+ **apiServers exchange** 
> 每一台数据服务节点都要持续向apiS exchange发送心跳消息.


> 所有的接口服务节点在启动以后都会创建一个消息队列来绑定这个exchange,任何发往这个exchange的消息都会被转发给绑定他的消息队列,一对多的通信.也就是说,每一个接口服务节点都会接收到任意一条数据服务节点的心跳消息.

+ **dataServers exchange**
> 接口服务要在收到对象GET请求时定位该对象被保存在哪个数据服务节点上.

> 所有的数据服务节点绑定在这个exchange,并需要接受来自接口服务的定位消息.拥有请求对象的数据服务节点则要是使用消息单发通知该接口服务节点.

+ 消息队列选择:
> ActiveMQ,ZeroMQ

### RabbitMQ消息设计
+ 数据服务的心跳消息
![Alt](./image/截图_选择区域_20220616191334.png#pic_center)

> 数据服务通过 RabbitMQ将自身的存在通知给所有的接口服务,这样的消息称为心跳消息,借助于RabbitMQ的群发.消息的正文是HTTP的监听地址.



+ 接口服务的定位消息及其反馈

![Alt](./image/截图_选择区域_20220616193039.png#pic_center)


## **分布式系统(+元数据服务)** 

+ 对于系统的持续改进:
> 多次PUT同一个对象,该对象会在所有的数据服务节点都有一份副本,显然这是不必要的,所以我们需要进行数据去重.

> 去重: 对于相同对象名的对象进行去重,对于不同名但是对象内容相同的也需要进行去重.

> 版本一致性:多次PUT同一个对象,且内容不同,这些对象的不同版本会被随机保存在不同的数据服务节点,当我们么GET时，多次GET,得到的对象数据可能不同,破坏了GET方法的幂等性.因此我们需要使我们的服务支持版本控制.

> 版本控制:将用户上传的某个对象的所有版本保存起来.


+ 什么是元数据?

> 将对象的数据和标识,描述对象的数据分开,标识对象的数据被称为元数据metadata.

+ 元数据类型:

> 系统自定义元数据 + 用户自定义元数据

+ 将接口服务层的访问对象和数据存储层的存取对象解耦

> 在对象存储中,对于接口服务层和客户端,我们可以用数据对象名称来标识.对于数据存储层,我们用数据对象数据本身的散列值hash来标识一个对象.这样可以使得数据去重时,不同对象名称但对象数据相同的对象进行去重服务.

> 元数据:对象名称,hash value,version,大小

+ 加上元数据架构演变结果:
1. 可以在不删除数据的情况下实现对象的删除功能.
2. 可以实现对象的版本控制,确保对象的数据一致性和GET方法的幂等性.


+ 当前架构的缺点:
1. 没有对客户端提供的对象hash值进行校验.
2. 对于相同数据的不同对象和相同对象的相同数据没有去重.



RabbitMQ学习
ES学习












